# 톰캣까지 예외 가는경우 1 진짜 예외 2 response.message
- 보통 해결되지 못하고 WAS까지 갈 경우 500

# 흐름
- 에러가 발생하면 > 톰캣에 senderror > 에러 발생 페이지 호출

# 필터, 인터셉터 사용, AOP 보다 이럴땐 필터 사용

# WAS > 필터 > ~ 흐름 (마치 가드처럼)

# 필터 이후 서블릿이 들어옴, 필터는 체인으로 구성(필터는 서블릿 기술)

# 로그 인증체크를 수행할때 필터와 인터셉터 둘다 사용

# 필터는 등록 과정이 있음

# 지금 시점에서 response 필터 이후 error 로그 출력

# 유틸이 아닌 서블릿 필터 사용

# 필터에 화이트리스트 사용(*css 포함해야함)

# 화이트리스트 > 미인증 체크 > 로그인 리다이렉트 > 로그인 성공 후 이전 페이지로 가도록(리다이렉트 uri 포함)

# 예외 로깅은 가능하지만 톰캣까지 throw로 올려주는게 나음

* 보통 필터나 부가 기능의 최적화는 크게 필요 없음

# 필터는 한 번 갔다가 다시 거쳐서 들어옴(스택이 pop 되듯이)
- 1차 필터 시작(request) > 2차 필터 호출 및 시작 > 2차 필터 pop > 1차 필터 pop(response)

# 요청이 들어오면 서블릿 컨테이너에서
1 스레드 할당과 ServletRequest, ServletResponse를 할당
2 필터 작동
3 요청에 맞는 서블릿을 찾아 서블릿을 호출

# 필터에 보통 스프링 시큐리티 적용해서 인증

# 필터는 서블릿, 인터셉터는 스프링 mvc

# http > 필터 > 서블릿 > 인터셉터 > 컨트롤러(mvc가 디스패쳐 서블릿이 시작점인걸 기억하면 쉬움)

# 서블릿 필터는 doFilter만 호출해서 가끔 메서드를 까먹는 실수를 많이함

# 인터셉터는 컨트롤러 호출 전, 호출 이후, 요청 이후 세 가지 구분
- preHandle, postHandle, afterCompletion

# 컨트롤러 예외가 터지면 postHandle은 x, 하지만 afterCompletion은 항상 호출됨(예외 정보 포함)

# 인터셉터 = mvc 특화 필터 기능

# mvc에서 사용하는 url 패턴은 따로 숙지

# 필터는 생성 단에서 화이트리스트 등 경로를 지정해야하지만 인터셉터는 등록시에 체이닝을 통해 가능

# 컨트롤러에서 sessionAttribute로 세션을 따로 받아 로직을 구현하지 않고 argumentResolver를 통해
객체로 간단히 받게 구현 가능

# 예외처리를 직접 구현하기 위해 1 customizer로 에러페이지 코딩 2 예외용 컨트롤러 코딩
- 스프링에선 에러페이지를 기본 제공

# 스프링 베이직에러컨트롤러에서 모델에 값을 담을 때 민감한 정보는 디폴트로 막아둠

# api요청시 리졸버 이용(스프링 인터페이스를 구현하기만 하면 됨)

# 스프링부트 기본 api 오류시 baasicController 호출(html / api 분리)

# html은 basicCont로 충분하지만 api는 스펙이 너무 다양해서 부족 > exceptionHandler

# resolver는 was에 예외를 던지지않고 postHandle 단계에 예외를 처리하고 정상 응답

# 이전 방법에선 예외가 was까지 던져지면 로그만 봐도 프로세스가 너무 비효율 > userHR 도입해서 예외를 아얘 다 처리

# 하지만 리졸버를 직접 구현하자니 너무 코드가 김 > 스프링이 제공



